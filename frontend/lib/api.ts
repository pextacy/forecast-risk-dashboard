import axios, { AxiosInstance, AxiosResponse, AxiosError } from 'axios';\nimport toast from 'react-hot-toast';\n\n// API Configuration\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';\n\n// Create axios instance\nexport const apiClient: AxiosInstance = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000, // 30 seconds\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Request interceptor\napiClient.interceptors.request.use(\n  (config) => {\n    // Add auth token if available\n    const token = localStorage.getItem('auth_token');\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    \n    // Log requests in development\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`🚀 API Request: ${config.method?.toUpperCase()} ${config.url}`);\n    }\n    \n    return config;\n  },\n  (error) => {\n    return Promise.reject(error);\n  }\n);\n\n// Response interceptor\napiClient.interceptors.response.use(\n  (response: AxiosResponse) => {\n    // Log successful responses in development\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`✅ API Response: ${response.config.url}`, response.data);\n    }\n    \n    return response;\n  },\n  (error: AxiosError) => {\n    // Handle common errors\n    if (error.response?.status === 401) {\n      // Unauthorized - redirect to login or clear auth\n      localStorage.removeItem('auth_token');\n      toast.error('Session expired. Please log in again.');\n    } else if (error.response?.status === 403) {\n      // Forbidden\n      toast.error('Access denied.');\n    } else if (error.response?.status === 404) {\n      // Not found\n      toast.error('Resource not found.');\n    } else if (error.response?.status >= 500) {\n      // Server error\n      toast.error('Server error. Please try again later.');\n    } else if (error.code === 'ECONNABORTED') {\n      // Timeout\n      toast.error('Request timeout. Please check your connection.');\n    } else if (error.message === 'Network Error') {\n      // Network error\n      toast.error('Network error. Please check your connection.');\n    }\n    \n    // Log errors in development\n    if (process.env.NODE_ENV === 'development') {\n      console.error(`❌ API Error: ${error.config?.url}`, error.response?.data || error.message);\n    }\n    \n    return Promise.reject(error);\n  }\n);\n\n// API Methods\nexport const api = {\n  // Health and Status\n  getHealth: () => apiClient.get('/health'),\n  getStatus: () => apiClient.get('/status'),\n  \n  // Forecasts\n  forecasts: {\n    getSupportedAssets: () => apiClient.get('/api/v1/forecasts/supported-assets'),\n    generate: (data: any) => apiClient.post('/api/v1/forecasts/generate', data),\n    batch: (data: any) => apiClient.post('/api/v1/forecasts/batch', data),\n    getAccuracy: (symbol: string, lookbackDays: number = 30) => \n      apiClient.get(`/api/v1/forecasts/accuracy/${symbol}`, { params: { lookback_days: lookbackDays } }),\n    getHistory: (symbol: string, limit: number = 10, offset: number = 0) => \n      apiClient.get(`/api/v1/forecasts/history/${symbol}`, { params: { limit, offset } }),\n    getLatest: (limit: number = 20) => \n      apiClient.get('/api/v1/forecasts/latest', { params: { limit } }),\n    refreshData: (symbol: string) => \n      apiClient.post(`/api/v1/forecasts/refresh-data/${symbol}`),\n    getVolatility: (symbol: string, windowDays: number = 30) => \n      apiClient.get(`/api/v1/forecasts/volatility/${symbol}`, { params: { window_days: windowDays } }),\n    getCorrelation: (symbols: string[], days: number = 30) => \n      apiClient.get('/api/v1/forecasts/correlation', { params: { symbols, days } }),\n  },\n  \n  // Portfolio and Balances\n  portfolio: {\n    getRiskMetrics: (data: any) => apiClient.post('/api/v1/balances/risk-metrics', data),\n    updateBalances: (data: any) => apiClient.post('/api/v1/balances/update-balances', data),\n    getCurrent: () => apiClient.get('/api/v1/balances/current'),\n    getHistory: (days: number = 30, walletAddress?: string) => \n      apiClient.get('/api/v1/balances/history', { \n        params: { days, wallet_address: walletAddress } \n      }),\n    optimize: (data: any) => apiClient.post('/api/v1/balances/optimize', data),\n    getPerformance: (portfolioWeights: any, days: number = 30) => \n      apiClient.get('/api/v1/balances/performance', { \n        params: { portfolio_weights: JSON.stringify(portfolioWeights), days } \n      }),\n    getRiskSummary: (portfolioWeights: any) => \n      apiClient.get('/api/v1/balances/risk-summary', { \n        params: { portfolio_weights: JSON.stringify(portfolioWeights) } \n      }),\n    clearBalances: (confirm: boolean = false, walletAddress?: string) => \n      apiClient.delete('/api/v1/balances/balances', { \n        params: { confirm, wallet_address: walletAddress } \n      }),\n  },\n  \n  // Hedge Suggestions\n  hedge: {\n    suggest: (data: any) => apiClient.post('/api/v1/hedge/suggest', data),\n    simulate: (data: any) => apiClient.post('/api/v1/hedge/simulate', data),\n    getAlerts: (portfolioWeights: any, riskTolerance: string = 'medium') => \n      apiClient.get('/api/v1/hedge/alerts', { \n        params: { \n          portfolio_weights: JSON.stringify(portfolioWeights), \n          risk_tolerance: riskTolerance \n        } \n      }),\n    getHistory: (limit: number = 20, offset: number = 0) => \n      apiClient.get('/api/v1/hedge/history', { params: { limit, offset } }),\n    backtest: (data: any) => apiClient.post('/api/v1/hedge/backtest', data),\n    getStrategies: () => apiClient.get('/api/v1/hedge/strategies'),\n    execute: (suggestionId: number, dryRun: boolean = true) => \n      apiClient.post('/api/v1/hedge/execute-suggestion', null, { \n        params: { suggestion_id: suggestionId, dry_run: dryRun } \n      }),\n  },\n  \n  // Admin\n  admin: {\n    ingestData: () => apiClient.post('/admin/ingest-data'),\n    getDatabaseStats: () => apiClient.get('/admin/database-stats'),\n  },\n};\n\n// Utility functions\nexport const handleApiError = (error: any, defaultMessage: string = 'An error occurred') => {\n  if (error.response?.data?.detail) {\n    return error.response.data.detail;\n  }\n  if (error.response?.data?.message) {\n    return error.response.data.message;\n  }\n  if (error.message) {\n    return error.message;\n  }\n  return defaultMessage;\n};\n\nexport const isApiError = (error: any): error is AxiosError => {\n  return error.isAxiosError === true;\n};\n\nexport default apiClient;"